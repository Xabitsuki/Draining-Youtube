from functions import *
import os
from multiprocessing import Process, Queue, cpu_count

def get_plylst_id(pth_vid):

    split = pth_vid.split(sep=pth_vids())[1].split('/')
    if len(split) == 3:

        plylst = split[1]
        id = split[2]

        return id, plylst

    elif len(split) == 2:

        id =split[1]
        return id , ''

## TODO implement get_pths_vids(plylst)

def make_sets(v_id, plylst=''):
    """Used after the iter_0 function ran to separate the frames into sets.
    Return the path the to the sets folder"""

    triangles = split_triangles(bin_matches_to_adja_mat(path_mtchs=pth_iter0_mtchs(v_id, plylst),
                                                        path_frames=pth_frms(v_id, plylst)))

    return move_triangles(triangles=triangles,
                          path_vid=pth_vid(v_id, plylst),
                          path_frames=pth_frms(v_id, plylst),
                          path_feats=pth_iter0_feats(v_id, plylst))


def iter0(path_vid, rate, frame_force=False, feature_force=False, match_force=False, sample=False):
    """Function used to make the first iteration of processing loop.
    Return: path_sets, width"""
    v_id, plylst = get_plylst_id(path_vid)

    # Extract frames
    if frame_force or not os.path.isdir(pth_frms(v_id, plylst)):
        xtrct_frame(v_id, plylst, sample, rate)

    # Make iter0 dir
    pth_it0 = pth_iter0(v_id, plylst)
    make_dir(pth_it0)

    # Listing
    path_frms = pth_frms(v_id, plylst)
    width = get_dic_info(path_vid)['width']
    cmd = "openMVG_main_SfMInit_ImageListing -i {} -o {} -f {}".format(path_frms, pth_it0, width)
    os.system(command=cmd)

    # Compute features
    path_feat = pth_iter0_feats(v_id, plylst)
    if feature_force or not os.path.isdir(path_feat):
        make_dir(path_feat)
        path_sfm = os.path.join(pth_it0, 'sfm_data.json')
        cmd = 'openMVG_main_ComputeFeatures -i {} -o {}'.format(path_sfm, path_feat)
        os.system(cmd)

    # Compute  matches
    if match_force or not os.path.isfile(pth_iter0_mtchs(v_id, plylst)):
        path_sfm = os.path.join(pth_it0, 'sfm_data.json')
        cmd = 'openMVG_main_ComputeMatches -i {} -o {}'.format(path_sfm, path_feat)
        os.system(cmd)

    # Make sets
    path_sets = pth_sets(v_id, plylst)
    if match_force or not os.path.isdir(path_sets):
        path_sets =  make_sets(v_id, plylst)

    remove_ds_store(path_sets)
    return path_sets, width


def sfm_pipe(pth_set, width):
    """Function that performs the sfm pipeline given the path to
    a set as generated by make_sets."""

    frames = os.path.join(pth_set, 'frames')
    features = os.path.join(pth_set, 'features')

    openmvg_list(width=width, pth_frms=frames, pth_out=pth_set)

    path_sfm = pth_sfm(pth_set)

    openmvg_features(pth_sfm=path_sfm, pth_features=features)

    openmvg_matches(pth_sfm=path_sfm, pth_matches=features)

    path_incr = os.path.join(pth_set, 'incremental')
    make_dir(path_incr)

    openmvg_incremental(pth_sfm=path_sfm, pth_matches=features, pth_incr=path_incr)

    openmvg_colors(pth_incr=path_incr)


class Worker:

    def __init__(self, task_queue):
        self.q = task_queue


    def Qiter0(self, args):
        """Performs iter0() and enqueues an sfm_pipe process with the generated sets."""
        path_set_dir, width = iter0(path_vid=pth_vid)
        pth_sets = [os.path.join(path_set_dir, el) for el in os.listdir(path_set_dir)]

        # Enqueue next tasks
        for pth_set in pth_sets:
            args = (pth_set, width)
            self.q.put(('sfm_pipe', args))


    def sfm_pipe(self, pth, width):
        sfm_pipe(pth_set=pth, width=width)


    def work(self, func, args):

        if func == 'Qiter0':
            self.Qiter0(*args)

        elif func == 'sfm_pipe':
            print('SFM PIPE')
            print(*args)
            self.sfm_pipe(*args)


def worker_exec(task_queue):
    # Work until no tasks are pending

    worker = Worker(task_queue)

    while not task_queue.empty():
        # instanciate worker
        func, args = task_queue.get()

        worker.work(func, args)


def drain(number_processes, rate, plylsts=[], vids=[]):
    # Enqueue Qiter0 tasks:
    Q = Queue()
    for plylst in plylsts:
        for v_id in os.listdir(pth_plylst(plylst)):
            args = (pth_vid(v_id, plylst),
                    rate)
            Q.put(('Qiter0', args))

    for v_id in vids:
        args = (pth_vid(v_id),
                rate)
        Q.put(('Qiter0', args))

    for i in range(number_processes):
        p = Process(target=worker_exec, args=(Q,))
        p.start()
